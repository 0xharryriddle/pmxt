{
    "_generated": "Auto-generated by extract-jsdoc.js on 2026-02-24T09:34:58.069Z. Do not edit manually.",
    "methods": {
        "loadMarkets": {
            "summary": "How long (ms) a market snapshot created by `fetchMarketsPaginated` remains valid",
            "description": "before being discarded and re-fetched from the API on the next call.\nDefaults to 0 (no TTL — the snapshot is re-fetched on every initial call).\n/\n    snapshotTTL?: number;\n}\n\n/** Shape returned by fetchMarketsPaginated */\nexport interface PaginatedMarketsResult {\n    data: UnifiedMarket[];\n    total: number;\n    nextCursor?: string;\n}\n\n// ----------------------------------------------------------------------------\n// Base Exchange Class\n// ----------------------------------------------------------------------------\n\nexport abstract class PredictionMarketExchange {\n    [key: string]: any; // Allow dynamic method assignment for implicit API\n\n    protected credentials?: ExchangeCredentials;\n    public verbose: boolean = false;\n    public http: AxiosInstance;\n    public enableRateLimit: boolean = true;\n    private _rateLimit: number = 1000;\n    private _throttler: Throttler;\n\n    // Snapshot state for cursor-based pagination\n    private _snapshotTTL: number;\n    private _snapshot?: { markets: UnifiedMarket[]; takenAt: number; id: string };\n\n    get rateLimit(): number {\n        return this._rateLimit;\n    }\n\n    set rateLimit(value: number) {\n        this._rateLimit = value;\n        this._throttler = new Throttler({\n            refillRate: 1 / value,\n            capacity: 1,\n            delay: 1,\n        });\n    }\n\n    // Market Cache\n    public markets: Record<string, UnifiedMarket> = {};\n    public marketsBySlug: Record<string, UnifiedMarket> = {};\n    public loadedMarkets: boolean = false;\n\n    // Implicit API (merged across multiple defineImplicitApi calls)\n    protected apiDescriptor?: ApiDescriptor;\n    private apiDescriptors: ApiDescriptor[] = [];\n\n    readonly has: ExchangeHas = {\n        fetchMarkets: false,\n        fetchEvents: false,\n        fetchOHLCV: false,\n        fetchOrderBook: false,\n        fetchTrades: false,\n        createOrder: false,\n        cancelOrder: false,\n        fetchOrder: false,\n        fetchOpenOrders: false,\n        fetchPositions: false,\n        fetchBalance: false,\n        watchOrderBook: false,\n        watchTrades: false,\n        fetchMyTrades: false,\n        fetchClosedOrders: false,\n        fetchAllOrders: false,\n    };\n\n    constructor(credentials?: ExchangeCredentials, options?: ExchangeOptions) {\n        this.credentials = credentials;\n        this._snapshotTTL = options?.snapshotTTL ?? 0;\n        this.http = axios.create();\n        this._throttler = new Throttler({\n            refillRate: 1 / this._rateLimit,\n            capacity: 1,\n            delay: 1,\n        });\n\n        // Rate Limit Interceptor\n        this.http.interceptors.request.use(async (config: InternalAxiosRequestConfig) => {\n            if (this.enableRateLimit) {\n                await this._throttler.throttle();\n            }\n            return config;\n        });\n\n        // Request Interceptor\n        this.http.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n            if (this.verbose) {\n                console.log(`\\n[pmxt] → ${config.method?.toUpperCase()} ${config.url}`);\n                if (config.params) console.log('[pmxt] params:', config.params);\n                if (config.data) console.log('[pmxt] body:', JSON.stringify(config.data, null, 2));\n            }\n            return config;\n        });\n\n        // Response Interceptor\n        this.http.interceptors.response.use(\n            (response: AxiosResponse) => {\n                if (this.verbose) {\n                    console.log(`\\n[pmxt] ← ${response.status} ${response.statusText} ${response.config.url}`);\n                    // console.log('[pmxt] response:', JSON.stringify(response.data, null, 2)); \n                    // Commented out full body log to avoid spam, but headers might be useful\n                }\n                return response;\n            },\n            (error: any) => {\n                if (this.verbose) {\n                    console.log(`\\n[pmxt] ✖ REQUEST FAILED: ${error.config?.url}`);\n                    console.log('[pmxt] error:', error.message);\n                    if (error.response) {\n                        console.log('[pmxt] status:', error.response.status);\n                        console.log('[pmxt] data:', JSON.stringify(error.response.data, null, 2));\n                    }\n                }\n                return Promise.reject(error);\n            }\n        );\n    }\n\n    abstract get name(): string;\n\n    /**\nLoad and cache all markets from the exchange into `this.markets` and `this.marketsBySlug`.\nSubsequent calls return the cached result without hitting the API again.\n\nThis is the correct way to paginate or iterate over markets without drift.\nBecause `fetchMarkets()` always hits the API, repeated calls with different `offset`\nvalues may return inconsistent results if the exchange reorders or adds markets between\nrequests. Use `loadMarkets()` once to get a stable snapshot, then paginate over\n`Object.values(exchange.markets)` locally.",
            "params": [
                {
                    "name": "reload",
                    "type": "boolean",
                    "optional": false,
                    "description": "Force a fresh fetch from the API even if markets are already loaded"
                }
            ],
            "returns": {
                "type": "Record<string, UnifiedMarket>",
                "description": "Dictionary of markets indexed by marketId"
            },
            "python": {
                "examples": [
                    {
                        "title": "Stable pagination",
                        "code": "exchange.load_markets()\nall = list(exchange.markets.values())\npage1 = all[:100]\npage2 = all[100:200]"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Stable pagination",
                        "code": "await exchange.loadMarkets();\nconst all = Object.values(exchange.markets);\nconst page1 = all.slice(0, 100);\nconst page2 = all.slice(100, 200);"
                    }
                ]
            },
            "source": "BaseExchange.ts:194"
        },
        "fetchMarkets": {
            "summary": "Fetch markets with optional filtering, search, or slug lookup.",
            "description": "Always hits the exchange API — results reflect the live state at the time of the call.",
            "params": [
                {
                    "name": "params",
                    "type": "MarketFetchParams",
                    "optional": true,
                    "description": "Optional parameters for filtering and search"
                }
            ],
            "subParams": [
                {
                    "name": "params.query",
                    "description": "Search keyword to filter markets"
                },
                {
                    "name": "params.slug",
                    "description": "Market slug/ticker for direct lookup"
                },
                {
                    "name": "params.limit",
                    "description": "Maximum number of results"
                },
                {
                    "name": "params.offset",
                    "description": "Pagination offset"
                },
                {
                    "name": "params.sort",
                    "description": "Sort order ('volume' | 'liquidity' | 'newest')"
                },
                {
                    "name": "params.searchIn",
                    "description": "Where to search ('title' | 'description' | 'both')"
                }
            ],
            "returns": {
                "type": "UnifiedMarket[]",
                "description": "Array of unified markets"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch markets",
                        "code": "markets = exchange.fetch_markets(query='Trump', limit=10000)\nprint(markets[0].title)"
                    },
                    {
                        "title": "Get market by slug",
                        "code": "markets = exchange.fetch_markets(slug='will-trump-win')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch markets",
                        "code": "const markets = await exchange.fetchMarkets({ query: 'Trump', limit: 10000 });\nconsole.log(markets[0].title);"
                    },
                    {
                        "title": "Get market by slug",
                        "code": "const markets = await exchange.fetchMarkets({ slug: 'will-trump-win' });"
                    }
                ]
            },
            "notes": [
                "ordering — exchanges may reorder or add markets between requests. For stable iteration\nacross pages, use `loadMarkets()` and paginate over `Object.values(exchange.markets)`.",
                "Some exchanges (like Limitless) may only support status 'active' for search results."
            ],
            "source": "BaseExchange.ts:371"
        },
        "fetchMarketsPaginated": {
            "summary": "Fetch markets with cursor-based pagination backed by a stable in-memory snapshot.",
            "description": "On the first call (or when no cursor is supplied), fetches all markets once and\ncaches them. Subsequent calls with a cursor returned from a previous call slice\ndirectly from the cached snapshot — no additional API calls are made.\n\nThe snapshot is invalidated after `snapshotTTL` ms (configured via `ExchangeOptions`\nin the constructor). A request using a cursor from an expired snapshot throws\n`'Cursor has expired'`.",
            "params": [
                {
                    "name": "params",
                    "type": "{ limit?: number; cursor?: string }",
                    "optional": true,
                    "description": "params"
                }
            ],
            "subParams": [
                {
                    "name": "params.limit",
                    "description": "Page size (default: return all markets)"
                },
                {
                    "name": "params.cursor",
                    "description": "Opaque cursor returned by a previous call"
                }
            ],
            "returns": {
                "type": "PaginatedMarketsResult",
                "description": "PaginatedMarketsResult with data, total, and optional nextCursor"
            },
            "python": {
                "examples": []
            },
            "typescript": {
                "examples": []
            },
            "source": "BaseExchange.ts:408"
        },
        "fetchEvents": {
            "summary": "Fetch events with optional keyword search.",
            "description": "Events group related markets together (e.g., \"Who will be Fed Chair?\" contains multiple candidate markets).",
            "params": [
                {
                    "name": "params",
                    "type": "EventFetchParams",
                    "optional": true,
                    "description": "Optional parameters for search and filtering"
                }
            ],
            "subParams": [
                {
                    "name": "params.query",
                    "description": "Search keyword to filter events (required)"
                },
                {
                    "name": "params.limit",
                    "description": "Maximum number of results"
                },
                {
                    "name": "params.offset",
                    "description": "Pagination offset"
                },
                {
                    "name": "params.searchIn",
                    "description": "Where to search ('title' | 'description' | 'both')"
                }
            ],
            "returns": {
                "type": "UnifiedEvent[]",
                "description": "Array of unified events"
            },
            "python": {
                "examples": [
                    {
                        "title": "Search events",
                        "code": "events = exchange.fetch_events(query='Fed Chair')\nfed_event = events[0]\nprint(fed_event.title, len(fed_event.markets), 'markets')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Search events",
                        "code": "const events = await exchange.fetchEvents({ query: 'Fed Chair' });\nconst fedEvent = events[0];\nconsole.log(fedEvent.title, fedEvent.markets.length, 'markets');"
                    }
                ]
            },
            "notes": [
                "Some exchanges (like Limitless) may only support status 'active' for search results."
            ],
            "source": "BaseExchange.ts:473"
        },
        "fetchMarket": {
            "summary": "Fetch a single market by lookup parameters.",
            "description": "Convenience wrapper around fetchMarkets() that returns a single result or throws MarketNotFound.",
            "params": [
                {
                    "name": "params",
                    "type": "MarketFetchParams",
                    "optional": true,
                    "description": "Lookup parameters (marketId, outcomeId, slug, etc.)"
                }
            ],
            "returns": {
                "type": "UnifiedMarket",
                "description": "A single unified market"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch by market ID",
                        "code": "market = exchange.fetch_market(market_id='663583')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch by market ID",
                        "code": "const market = await exchange.fetchMarket({ marketId: '663583' });"
                    },
                    {
                        "title": "Fetch by outcome ID",
                        "code": "const market = await exchange.fetchMarket({ outcomeId: '10991849...' });"
                    }
                ]
            },
            "source": "BaseExchange.ts:503"
        },
        "fetchEvent": {
            "summary": "Fetch a single event by lookup parameters.",
            "description": "Convenience wrapper around fetchEvents() that returns a single result or throws EventNotFound.",
            "params": [
                {
                    "name": "params",
                    "type": "EventFetchParams",
                    "optional": true,
                    "description": "Lookup parameters (eventId, slug, query)"
                }
            ],
            "returns": {
                "type": "UnifiedEvent",
                "description": "A single unified event"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch by event ID",
                        "code": "event = exchange.fetch_event(event_id='TRUMP25DEC')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch by event ID",
                        "code": "const event = await exchange.fetchEvent({ eventId: 'TRUMP25DEC' });"
                    }
                ]
            },
            "source": "BaseExchange.ts:539"
        },
        "fetchOHLCV": {
            "summary": "Fetch historical OHLCV (candlestick) price data for a specific market outcome.",
            "description": "Fetch historical OHLCV (candlestick) price data for a specific market outcome.",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The Outcome ID (outcomeId). Use outcome.outcomeId, NOT market.marketId"
                },
                {
                    "name": "params",
                    "type": "OHLCVParams | HistoryFilterParams",
                    "optional": false,
                    "description": "OHLCV parameters including resolution (required)"
                }
            ],
            "returns": {
                "type": "PriceCandle[]",
                "description": "Array of price candles"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch hourly candles",
                        "code": "markets = exchange.fetch_markets(query='Trump')\noutcome_id = markets[0].yes.outcome_id\ncandles = exchange.fetch_ohlcv(outcome_id, resolution='1h', limit=100)\nprint(f\"Latest close: {candles[-1].close}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch hourly candles",
                        "code": "const markets = await exchange.fetchMarkets({ query: 'Trump' });\nconst outcomeId = markets[0].yes.outcomeId;\nconst candles = await exchange.fetchOHLCV(outcomeId, {\n  resolution: '1h',\n  limit: 100\n});\nconsole.log(`Latest close: ${candles[candles.length - 1].close}`);"
                    }
                ]
            },
            "notes": [
                "**CRITICAL**: Use `outcome.outcomeId` (TS) / `outcome.outcome_id` (Python), not the market ID.",
                "Polymarket: outcomeId is the CLOB Token ID. Kalshi: outcomeId is the Market Ticker.",
                "Resolution options: '1m' | '5m' | '15m' | '1h' | '6h' | '1d'"
            ],
            "source": "BaseExchange.ts:583"
        },
        "fetchOrderBook": {
            "summary": "Fetch the current order book (bids/asks) for a specific outcome.",
            "description": "Essential for calculating spread, depth, and execution prices.",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The Outcome ID (outcomeId)"
                }
            ],
            "returns": {
                "type": "OrderBook",
                "description": "Current order book with bids and asks"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch order book",
                        "code": "book = exchange.fetch_order_book(outcome.outcome_id)\nprint(f\"Best bid: {book.bids[0].price}\")\nprint(f\"Best ask: {book.asks[0].price}\")\nprint(f\"Spread: {(book.asks[0].price - book.bids[0].price) * 100:.2f}%\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch order book",
                        "code": "const book = await exchange.fetchOrderBook(outcome.outcomeId);\nconsole.log(`Best bid: ${book.bids[0].price}`);\nconsole.log(`Best ask: ${book.asks[0].price}`);\nconsole.log(`Spread: ${(book.asks[0].price - book.bids[0].price) * 100}%`);"
                    }
                ]
            },
            "source": "BaseExchange.ts:613"
        },
        "fetchTrades": {
            "summary": "Fetch raw trade history for a specific outcome.",
            "description": "Fetch raw trade history for a specific outcome.",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The Outcome ID (outcomeId)"
                },
                {
                    "name": "params",
                    "type": "TradesParams | HistoryFilterParams",
                    "optional": false,
                    "description": "Trade filter parameters"
                }
            ],
            "returns": {
                "type": "Trade[]",
                "description": "Array of recent trades"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch recent trades",
                        "code": "trades = exchange.fetch_trades(outcome.outcome_id, limit=100)\nfor trade in trades:\n    print(f\"{trade.side} {trade.amount} @ {trade.price}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch recent trades",
                        "code": "const trades = await exchange.fetchTrades(outcome.outcomeId, { limit: 100 });\nfor (const trade of trades) {\n  console.log(`${trade.side} ${trade.amount} @ ${trade.price}`);\n}"
                    }
                ]
            },
            "notes": [
                "Polymarket requires an API key for trade history. Use fetchOHLCV for public historical data."
            ],
            "source": "BaseExchange.ts:636"
        },
        "createOrder": {
            "summary": "Place a new order on the exchange.",
            "description": "Place a new order on the exchange.",
            "params": [
                {
                    "name": "params",
                    "type": "CreateOrderParams",
                    "optional": false,
                    "description": "Order parameters"
                }
            ],
            "returns": {
                "type": "Order",
                "description": "The created order"
            },
            "python": {
                "examples": [
                    {
                        "title": "Place a limit order",
                        "code": "order = exchange.create_order(\n    market_id=market.market_id,\n    outcome_id=market.yes.outcome_id,\n    side='buy',\n    type='limit',\n    amount=10,\n    price=0.55\n)\nprint(f\"Order {order.id}: {order.status}\")"
                    },
                    {
                        "title": "Place a market order",
                        "code": "order = exchange.create_order(\n    market_id=market.market_id,\n    outcome_id=market.yes.outcome_id,\n    side='buy',\n    type='market',\n    amount=5\n)"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Place a limit order",
                        "code": "const order = await exchange.createOrder({\n  marketId: market.marketId,\n  outcomeId: market.yes.outcomeId,\n  side: 'buy',\n  type: 'limit',\n  amount: 10,\n  price: 0.55\n});\nconsole.log(`Order ${order.id}: ${order.status}`);"
                    },
                    {
                        "title": "Place a market order",
                        "code": "const order = await exchange.createOrder({\n  marketId: market.marketId,\n  outcomeId: market.yes.outcomeId,\n  side: 'buy',\n  type: 'market',\n  amount: 5\n});"
                    }
                ]
            },
            "source": "BaseExchange.ts:671"
        },
        "cancelOrder": {
            "summary": "Cancel an existing open order.",
            "description": "Cancel an existing open order.",
            "params": [
                {
                    "name": "orderId",
                    "type": "string",
                    "optional": false,
                    "description": "The order ID to cancel"
                }
            ],
            "returns": {
                "type": "Order",
                "description": "The cancelled order"
            },
            "python": {
                "examples": [
                    {
                        "title": "Cancel an order",
                        "code": "cancelled = exchange.cancel_order('order-123')\nprint(cancelled.status)  # 'cancelled'"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Cancel an order",
                        "code": "const cancelled = await exchange.cancelOrder('order-123');\nconsole.log(cancelled.status); // 'cancelled'"
                    }
                ]
            },
            "source": "BaseExchange.ts:721"
        },
        "fetchOrder": {
            "summary": "Fetch a specific order by ID.",
            "description": "Fetch a specific order by ID.",
            "params": [
                {
                    "name": "orderId",
                    "type": "string",
                    "optional": false,
                    "description": "The order ID to look up"
                }
            ],
            "returns": {
                "type": "Order",
                "description": "The order details"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch order status",
                        "code": "order = exchange.fetch_order('order-456')\nprint(f\"Filled: {order.filled}/{order.amount}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch order status",
                        "code": "const order = await exchange.fetchOrder('order-456');\nconsole.log(`Filled: ${order.filled}/${order.amount}`);"
                    }
                ]
            },
            "source": "BaseExchange.ts:739"
        },
        "fetchOpenOrders": {
            "summary": "Fetch all open orders, optionally filtered by market.",
            "description": "Fetch all open orders, optionally filtered by market.",
            "params": [
                {
                    "name": "marketId",
                    "type": "string",
                    "optional": true,
                    "description": "Optional market ID to filter by"
                }
            ],
            "returns": {
                "type": "Order[]",
                "description": "Array of open orders"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch all open orders",
                        "code": "orders = exchange.fetch_open_orders()\nfor order in orders:\n    print(f\"{order.side} {order.amount} @ {order.price}\")"
                    },
                    {
                        "title": "Fetch orders for a specific market",
                        "code": "orders = exchange.fetch_open_orders('FED-25JAN')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch all open orders",
                        "code": "const orders = await exchange.fetchOpenOrders();\nfor (const order of orders) {\n  console.log(`${order.side} ${order.amount} @ ${order.price}`);\n}"
                    },
                    {
                        "title": "Fetch orders for a specific market",
                        "code": "const orders = await exchange.fetchOpenOrders('FED-25JAN');"
                    }
                ]
            },
            "source": "BaseExchange.ts:757"
        },
        "fetchPositions": {
            "summary": "Fetch current user positions across all markets.",
            "description": "Fetch current user positions across all markets.",
            "params": [],
            "returns": {
                "type": "Position[]",
                "description": "Array of user positions"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch positions",
                        "code": "positions = exchange.fetch_positions()\nfor pos in positions:\n    print(f\"{pos.outcome_label}: {pos.size} @ ${pos.entry_price}\")\n    print(f\"Unrealized P&L: ${pos.unrealized_pnl:.2f}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch positions",
                        "code": "const positions = await exchange.fetchPositions();\nfor (const pos of positions) {\n  console.log(`${pos.outcomeLabel}: ${pos.size} @ $${pos.entryPrice}`);\n  console.log(`Unrealized P&L: $${pos.unrealizedPnL.toFixed(2)}`);\n}"
                    }
                ]
            },
            "source": "BaseExchange.ts:796"
        },
        "fetchBalance": {
            "summary": "Fetch account balances.",
            "description": "Fetch account balances.",
            "params": [],
            "returns": {
                "type": "Balance[]",
                "description": "Array of account balances"
            },
            "python": {
                "examples": [
                    {
                        "title": "Fetch balance",
                        "code": "balances = exchange.fetch_balance()\nprint(f\"Available: ${balances[0].available}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Fetch balance",
                        "code": "const balances = await exchange.fetchBalance();\nconsole.log(`Available: $${balances[0].available}`);"
                    }
                ]
            },
            "source": "BaseExchange.ts:818"
        },
        "getExecutionPrice": {
            "summary": "Calculate the volume-weighted average execution price for a given order size.",
            "description": "Returns 0 if the order cannot be fully filled.",
            "params": [
                {
                    "name": "orderBook",
                    "type": "OrderBook",
                    "optional": false,
                    "description": "The current order book"
                },
                {
                    "name": "side",
                    "type": "'buy' | 'sell'",
                    "optional": false,
                    "description": "'buy' or 'sell'"
                },
                {
                    "name": "amount",
                    "type": "number",
                    "optional": false,
                    "description": "Number of contracts to simulate"
                }
            ],
            "returns": {
                "type": "number",
                "description": "Average execution price, or 0 if insufficient liquidity"
            },
            "python": {
                "examples": [
                    {
                        "title": "Get execution price",
                        "code": "book = exchange.fetch_order_book(outcome.outcome_id)\nprice = exchange.get_execution_price(book, 'buy', 100)\nprint(f\"Avg price for 100 contracts: {price}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Get execution price",
                        "code": "const book = await exchange.fetchOrderBook(outcome.outcomeId);\nconst price = exchange.getExecutionPrice(book, 'buy', 100);\nconsole.log(`Avg price for 100 contracts: ${price}`);"
                    }
                ]
            },
            "source": "BaseExchange.ts:835"
        },
        "getExecutionPriceDetailed": {
            "summary": "Calculate detailed execution price information including partial fill data.",
            "description": "Calculate detailed execution price information including partial fill data.",
            "params": [
                {
                    "name": "orderBook",
                    "type": "OrderBook",
                    "optional": false,
                    "description": "The current order book"
                },
                {
                    "name": "side",
                    "type": "'buy' | 'sell'",
                    "optional": false,
                    "description": "'buy' or 'sell'"
                },
                {
                    "name": "amount",
                    "type": "number",
                    "optional": false,
                    "description": "Number of contracts to simulate"
                }
            ],
            "returns": {
                "type": "ExecutionPriceResult",
                "description": "Detailed execution result with price, filled amount, and fill status"
            },
            "python": {
                "examples": [
                    {
                        "title": "Get detailed execution price",
                        "code": "book = exchange.fetch_order_book(outcome.outcome_id)\nresult = exchange.get_execution_price_detailed(book, 'buy', 100)\nprint(f\"Price: {result.price}\")\nprint(f\"Filled: {result.filled_amount}/100\")\nprint(f\"Fully filled: {result.fully_filled}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Get detailed execution price",
                        "code": "const book = await exchange.fetchOrderBook(outcome.outcomeId);\nconst result = exchange.getExecutionPriceDetailed(book, 'buy', 100);\nconsole.log(`Price: ${result.price}`);\nconsole.log(`Filled: ${result.filledAmount}/${100}`);\nconsole.log(`Fully filled: ${result.fullyFilled}`);"
                    }
                ]
            },
            "source": "BaseExchange.ts:858"
        },
        "filterMarkets": {
            "summary": "Filter a list of markets by criteria.",
            "description": "Can filter by string query, structured criteria object, or custom filter function.",
            "params": [
                {
                    "name": "markets",
                    "type": "UnifiedMarket[]",
                    "optional": false,
                    "description": "Array of markets to filter"
                },
                {
                    "name": "criteria",
                    "type": "string | MarketFilterCriteria | MarketFilterFunction",
                    "optional": false,
                    "description": "Filter criteria: string (text search), object (structured), or function (predicate)"
                }
            ],
            "returns": {
                "type": "UnifiedMarket[]",
                "description": "Filtered array of markets"
            },
            "python": {
                "examples": [
                    {
                        "title": "Simple text search",
                        "code": "filtered = exchange.filter_markets(markets, 'Trump')"
                    },
                    {
                        "title": "Advanced criteria",
                        "code": "undervalued = exchange.filter_markets(markets, {\n    'text': 'Election',\n    'volume_24h': {'min': 10000},\n    'price': {'outcome': 'yes', 'max': 0.4}\n})"
                    },
                    {
                        "title": "Custom predicate",
                        "code": "volatile = exchange.filter_markets(markets,\n    lambda m: m.yes and m.yes.price_change_24h < -0.1\n)"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Simple text search",
                        "code": "const filtered = exchange.filterMarkets(markets, 'Trump');"
                    },
                    {
                        "title": "Advanced criteria",
                        "code": "const undervalued = exchange.filterMarkets(markets, {\n  text: 'Election',\n  volume24h: { min: 10000 },\n  price: { outcome: 'yes', max: 0.4 }\n});"
                    },
                    {
                        "title": "Custom predicate",
                        "code": "const volatile = exchange.filterMarkets(markets,\n  m => m.yes?.priceChange24h < -0.1\n);"
                    }
                ]
            },
            "source": "BaseExchange.ts:892"
        },
        "filterEvents": {
            "summary": "Filter a list of events by criteria.",
            "description": "Can filter by string query, structured criteria object, or custom filter function.",
            "params": [
                {
                    "name": "events",
                    "type": "UnifiedEvent[]",
                    "optional": false,
                    "description": "Array of events to filter"
                },
                {
                    "name": "criteria",
                    "type": "string | EventFilterCriteria | EventFilterFunction",
                    "optional": false,
                    "description": "Filter criteria: string (text search), object (structured), or function (predicate)"
                }
            ],
            "returns": {
                "type": "UnifiedEvent[]",
                "description": "Filtered array of events"
            },
            "python": {
                "examples": [
                    {
                        "title": "Filter by category",
                        "code": "filtered = exchange.filter_events(events, {\n    'category': 'Politics',\n    'market_count': {'min': 5}\n})"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Filter by category",
                        "code": "const filtered = exchange.filterEvents(events, {\n  category: 'Politics',\n  marketCount: { min: 5 }\n});"
                    }
                ]
            },
            "source": "BaseExchange.ts:1077"
        },
        "watchOrderBook": {
            "summary": "Watch order book updates in real-time via WebSocket.",
            "description": "Returns a promise that resolves with the next order book update. Call repeatedly in a loop to stream updates (CCXT Pro pattern).",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The Outcome ID to watch"
                },
                {
                    "name": "limit",
                    "type": "number",
                    "optional": true,
                    "description": "Optional limit for orderbook depth"
                }
            ],
            "returns": {
                "type": "OrderBook",
                "description": "Promise that resolves with the current orderbook state"
            },
            "python": {
                "examples": [
                    {
                        "title": "Stream order book",
                        "code": "while True:\n    book = exchange.watch_order_book(outcome.outcome_id)\n    print(f\"Bid: {book.bids[0].price} Ask: {book.asks[0].price}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Stream order book",
                        "code": "while (true) {\n  const book = await exchange.watchOrderBook(outcome.outcomeId);\n  console.log(`Bid: ${book.bids[0]?.price} Ask: ${book.asks[0]?.price}`);\n}"
                    }
                ]
            },
            "source": "BaseExchange.ts:1189"
        },
        "watchTrades": {
            "summary": "Watch trade executions in real-time via WebSocket.",
            "description": "Returns a promise that resolves with the next trade(s). Call repeatedly in a loop to stream updates (CCXT Pro pattern).",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The Outcome ID to watch"
                },
                {
                    "name": "since",
                    "type": "number",
                    "optional": true,
                    "description": "Optional timestamp to filter trades from"
                },
                {
                    "name": "limit",
                    "type": "number",
                    "optional": true,
                    "description": "Optional limit for number of trades"
                }
            ],
            "returns": {
                "type": "Trade[]",
                "description": "Promise that resolves with recent trades"
            },
            "python": {
                "examples": [
                    {
                        "title": "Stream trades",
                        "code": "while True:\n    trades = exchange.watch_trades(outcome.outcome_id)\n    for trade in trades:\n        print(f\"{trade.side} {trade.amount} @ {trade.price}\")"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Stream trades",
                        "code": "while (true) {\n  const trades = await exchange.watchTrades(outcome.outcomeId);\n  for (const trade of trades) {\n    console.log(`${trade.side} ${trade.amount} @ ${trade.price}`);\n  }\n}"
                    }
                ]
            },
            "source": "BaseExchange.ts:1212"
        },
        "close": {
            "summary": "Close all WebSocket connections and clean up resources.",
            "description": "Call this when you're done streaming to properly release connections.",
            "params": [],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": [
                    {
                        "title": "Close connections",
                        "code": "exchange.close()"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Close connections",
                        "code": "await exchange.close();"
                    }
                ]
            },
            "source": "BaseExchange.ts:1239"
        },
        "implicitApi": {
            "summary": "Introspection getter: returns info about all implicit API methods.",
            "description": "Introspection getter: returns info about all implicit API methods.",
            "params": [],
            "returns": {
                "type": "ImplicitApiMethodInfo[]",
                "description": "Result"
            },
            "python": {
                "examples": []
            },
            "typescript": {
                "examples": []
            },
            "source": "BaseExchange.ts:1370"
        },
        "watchPrices": {
            "summary": "Watch AMM price updates for a market address (Limitless only).",
            "description": "Requires WebSocket connection.",
            "params": [
                {
                    "name": "marketAddress",
                    "type": "string",
                    "optional": false,
                    "description": "Market contract address"
                },
                {
                    "name": "callback",
                    "type": "(data: any)",
                    "optional": false,
                    "description": "Callback for price updates"
                }
            ],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": [
                    {
                        "title": "Watch prices",
                        "code": "exchange.watch_prices(market_address, callback=lambda data: print('Price update:', data))"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Watch prices",
                        "code": "await exchange.watchPrices(marketAddress, (data) => {\n  console.log('Price update:', data);\n});"
                    }
                ]
            },
            "exchangeOnly": "limitless",
            "source": "index.ts:453"
        },
        "watchUserPositions": {
            "summary": "Watch user positions in real-time (Limitless only).",
            "description": "Requires API key authentication.",
            "params": [
                {
                    "name": "callback",
                    "type": "(data: any)",
                    "optional": false,
                    "description": "Callback for position updates"
                }
            ],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": [
                    {
                        "title": "Watch positions",
                        "code": "exchange.watch_user_positions(callback=lambda data: print('Position update:', data))"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Watch positions",
                        "code": "await exchange.watchUserPositions((data) => {\n  console.log('Position update:', data);\n});"
                    }
                ]
            },
            "exchangeOnly": "limitless",
            "source": "index.ts:473"
        },
        "watchUserTransactions": {
            "summary": "Watch user transactions in real-time (Limitless only).",
            "description": "Requires API key authentication.",
            "params": [
                {
                    "name": "callback",
                    "type": "(data: any)",
                    "optional": false,
                    "description": "Callback for transaction updates"
                }
            ],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": [
                    {
                        "title": "Watch transactions",
                        "code": "exchange.watch_user_transactions(callback=lambda data: print('Transaction:', data))"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Watch transactions",
                        "code": "await exchange.watchUserTransactions((data) => {\n  console.log('Transaction:', data);\n});"
                    }
                ]
            },
            "exchangeOnly": "limitless",
            "source": "index.ts:493"
        },
        "initAuth": {
            "summary": "Initialize L2 API credentials for implicit API signing.",
            "description": "Must be called before using private implicit API endpoints if only\na privateKey was provided (not apiKey/apiSecret/passphrase).",
            "params": [],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": []
            },
            "typescript": {
                "examples": []
            },
            "exchangeOnly": "polymarket",
            "source": "index.ts:104"
        },
        "preWarmMarket": {
            "summary": "Pre-warm the SDK's internal caches for a market outcome.",
            "description": "Fetches tick size, fee rate, and neg-risk in parallel so that subsequent\n`createOrder` calls skip those lookups and hit only `POST /order`.\nCall this when you start watching a market.",
            "params": [
                {
                    "name": "outcomeId",
                    "type": "string",
                    "optional": false,
                    "description": "The CLOB Token ID for the outcome (use `outcome.outcomeId`)"
                }
            ],
            "returns": {
                "type": "void",
                "description": "Result"
            },
            "python": {
                "examples": [
                    {
                        "title": "Pre-warm before placing orders",
                        "code": "markets = exchange.fetch_markets(query='Trump')\noutcome_id = markets[0].outcomes[0].outcome_id\nexchange.pre_warm_market(outcome_id)\n# Subsequent create_order calls are faster"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Pre-warm before placing orders",
                        "code": "const markets = await exchange.fetchMarkets({ query: 'Trump' });\nconst outcomeId = markets[0].outcomes[0].outcomeId;\nawait exchange.preWarmMarket(outcomeId);\n// Subsequent createOrder calls are faster"
                    }
                ]
            },
            "exchangeOnly": "polymarket",
            "source": "index.ts:231"
        },
        "getEventById": {
            "summary": "Fetch a single event by its numeric ID (Probable only).",
            "description": "Fetch a single event by its numeric ID (Probable only).",
            "params": [
                {
                    "name": "id",
                    "type": "string",
                    "optional": false,
                    "description": "The numeric event ID"
                }
            ],
            "returns": {
                "type": "UnifiedEvent | null",
                "description": "The UnifiedEvent, or null if not found"
            },
            "python": {
                "examples": [
                    {
                        "title": "Get event by ID",
                        "code": "event = exchange.get_event_by_id('42')\nif event:\n    print(event.title)\n    print(len(event.markets), 'markets')"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Get event by ID",
                        "code": "const event = await exchange.getEventById('42');\nif (event) {\n  console.log(event.title);\n  console.log(event.markets.length, 'markets');\n}"
                    }
                ]
            },
            "exchangeOnly": "probable",
            "source": "index.ts:133"
        },
        "getEventBySlug": {
            "summary": "Fetch a single event by its URL slug (Probable only).",
            "description": "Fetch a single event by its URL slug (Probable only).",
            "params": [
                {
                    "name": "slug",
                    "type": "string",
                    "optional": false,
                    "description": "The event's URL slug (e.g. `\"trump-2024-election\"`)"
                }
            ],
            "returns": {
                "type": "UnifiedEvent | null",
                "description": "The UnifiedEvent, or null if not found"
            },
            "python": {
                "examples": [
                    {
                        "title": "Get event by slug",
                        "code": "event = exchange.get_event_by_slug('trump-2024-election')\nif event:\n    print(event.title)"
                    }
                ]
            },
            "typescript": {
                "examples": [
                    {
                        "title": "Get event by slug",
                        "code": "const event = await exchange.getEventBySlug('trump-2024-election');\nif (event) {\n  console.log(event.title);\n}"
                    }
                ]
            },
            "exchangeOnly": "probable",
            "source": "index.ts:156"
        }
    },
    "workflowExample": {
        "python": "import pmxt\nimport os\n\nexchange = pmxt.Polymarket(\n    private_key=os.getenv('POLYMARKET_PRIVATE_KEY')\n)\n\n# 1. Check balance\nbalances = exchange.fetch_balance()\nif balances:\n    balance = balances[0]\n    print(f'Available: ${balance.available}')\n\n# 2. Search for a market\nmarkets = exchange.fetch_markets(query='Trump')\nmarket = markets[0]\noutcome = market.yes\n\nprint(f'{market.title}')\nprint(f'Price: {outcome.price * 100:.1f}%')\n\n# 3. Place a limit order\norder = exchange.create_order(\n    market_id=market.market_id,\n    outcome_id=outcome.outcome_id,\n    side='buy',\n    type='limit',\n    amount=10,\n    price=0.50\n)\n\nprint(f'Order placed: {order.id}')\n\n# 4. Check order status\nupdated_order = exchange.fetch_order(order.id)\nprint(f'Status: {updated_order.status}')\nprint(f'Filled: {updated_order.filled}/{updated_order.amount}')\n\n# 5. Cancel if needed\nif updated_order.status == 'open':\n    exchange.cancel_order(order.id)\n    print('Order cancelled')\n\n# 6. Check positions\npositions = exchange.fetch_positions()\nfor pos in positions:\n    pnl_sign = '+' if pos.unrealized_pnl > 0 else ''\n    print(f'{pos.outcome_label}: {pnl_sign}${pos.unrealized_pnl:.2f}')",
        "typescript": "import pmxt from 'pmxtjs';\n\nconst exchange = new pmxt.Polymarket({\n  privateKey: process.env.POLYMARKET_PRIVATE_KEY\n});\n\n// 1. Check balance\nconst [balance] = await exchange.fetchBalance();\nconsole.log(`Available: $${balance.available}`);\n\n// 2. Search for a market\nconst markets = await exchange.fetchMarkets({ query: 'Trump' });\nconst market = markets[0];\nconst outcome = market.yes;\n\nconsole.log(market.title);\nconsole.log(`Price: ${(outcome.price * 100).toFixed(1)}%`);\n\n// 3. Place a limit order\nconst order = await exchange.createOrder({\n  marketId: market.marketId,\n  outcomeId: outcome.outcomeId,\n  side: 'buy',\n  type: 'limit',\n  amount: 10,\n  price: 0.50\n});\n\nconsole.log(`Order placed: ${order.id}`);\n\n// 4. Check order status\nconst updatedOrder = await exchange.fetchOrder(order.id);\nconsole.log(`Status: ${updatedOrder.status}`);\nconsole.log(`Filled: ${updatedOrder.filled}/${updatedOrder.amount}`);\n\n// 5. Cancel if needed\nif (updatedOrder.status === 'open') {\n  await exchange.cancelOrder(order.id);\n  console.log('Order cancelled');\n}\n\n// 6. Check positions\nconst positions = await exchange.fetchPositions();\npositions.forEach(pos => {\n  console.log(`${pos.outcomeLabel}: ${pos.unrealizedPnL > 0 ? '+' : ''}$${pos.unrealizedPnL.toFixed(2)}`);\n});"
    }
}